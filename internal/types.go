package internal

import (
	"crypto/rand"
	"encoding/binary"
	"io"

	"filippo.io/edwards25519"
)

// Element represents a point on the edwards25519 curve.
type Element struct {
	e *edwards25519.Point
}

// Scalar represents a scalar value in the edwards25519 field.
type Scalar struct {
	s *edwards25519.Scalar
}

// Participant holds the information about a single participant in the signing
// protocol.
type Participant struct {
	// Identifier is the participant's identifier. It is a non-zero scalar.
	Identifier *Scalar

	// PublicKeyShare is the participant's public key share.
	PublicKeyShare *Element
}

// Commitment represents a commitment from a participant in the first round of
// the signing protocol.
type Commitment struct {
	// Identifier is the participant's identifier.
	Identifier *Scalar

	// Hiding is the hiding nonce commitment.
	Hiding *Element

	// Binding is the binding nonce commitment.
	Binding *Element
}

// Nonce is a pair of scalar values generated by a participant in the first
// round of the signing protocol.
type Nonce struct {
	Hiding  *Scalar
	Binding *Scalar
}

// SignatureShare is a share of the final signature, produced by a participant
// in the second round of the signing protocol.
type SignatureShare struct {
	// Identifier is the participant's identifier.
	Identifier *Scalar

	// Share is the signature share.
	Share *Scalar
}

// GroupKey represents the public key for the group.
type GroupKey struct {
	// Element is the group's public key.
	Element *Element
}

// SecretShare represents a participant's secret key share.
type SecretShare struct {
	// Identifier is the participant's identifier.
	Identifier *Scalar

	// Scalar is the secret key share.
	Scalar *Scalar
}

// Signature is a FROST signature.
type Signature struct {
	// R is the group commitment.
	R *Element

	// Z is the aggregated signature share.
	Z *Scalar
}

// NewElement creates a new Element.
func NewElement() *Element {
	return &Element{e: edwards25519.NewIdentityPoint()}
}

// NewScalar creates a new Scalar.
func NewScalar() *Scalar {
	return &Scalar{s: edwards25519.NewScalar()}
}

// Generate a random scalar
func RandomScalar() (*Scalar, error) {
	b := make([]byte, 64)
	_, err := io.ReadFull(rand.Reader, b)
	if err != nil {
		return nil, err
	}
	s, err := edwards25519.NewScalar().SetUniformBytes(b)
	if err != nil {
		return nil, err
	}
	return &Scalar{s: s}, nil
}

// Set an element from bytes
func (e *Element) SetBytes(b []byte) (*Element, error) {
	p := new(edwards25519.Point)
	_, err := p.SetBytes(b)
	if err != nil {
		return nil, err
	}
	e.e = p
	return e, nil
}

// Set a scalar from bytes
func (s *Scalar) SetBytes(b []byte) (*Scalar, error) {
	sc, err := edwards25519.NewScalar().SetCanonicalBytes(b)
	if err != nil {
		return nil, err
	}
	s.s = sc
	return s, nil
}

// Bytes returns the byte representation of the element.
func (e *Element) Bytes() []byte {
	return e.e.Bytes()
}

// Bytes returns the byte representation of the scalar.
func (s *Scalar) Bytes() []byte {
	return s.s.Bytes()
}

// Add adds two elements.
func (e *Element) Add(a, b *Element) *Element {
	e.e.Add(a.e, b.e)
	return e
}

// Sub subtracts two elements.
func (e *Element) Sub(a, b *Element) *Element {
	e.e.Subtract(a.e, b.e)
	return e
}

// Mul multiplies a scalar by an element.
func (e *Element) Mul(s *Scalar, p *Element) *Element {
	if p == nil {
		e.e.ScalarBaseMult(s.s)
		return e
	}
	e.e.ScalarMult(s.s, p.e)
	return e
}

// Base sets the element to the base point.
func (e *Element) Base() *Element {
	e.e = edwards25519.NewGeneratorPoint()
	return e
}

// Add adds two scalars.
func (s *Scalar) Add(a, b *Scalar) *Scalar {
	s.s.Add(a.s, b.s)
	return s
}

// Mul multiplies two scalars.
func (s *Scalar) Mul(a, b *Scalar) *Scalar {
	s.s.Multiply(a.s, b.s)
	return s
}

// Sub subtracts two scalars.
func (s *Scalar) Sub(a, b *Scalar) *Scalar {
	s.s.Subtract(a.s, b.s)
	return s
}

// Invert inverts a scalar.
func (s *Scalar) Invert(a *Scalar) *Scalar {
	s.s.Invert(a.s)
	return s
}

// Equal compares two scalars.
func (s *Scalar) Equal(other *Scalar) bool {
	return s.s.Equal(other.s) == 1
}

func (e *Element) Equal(other *Element) bool {
	return e.e.Equal(other.e) == 1
}

// SetUint64 sets the scalar to a uint64 value.
func (s *Scalar) SetUint64(n uint64) *Scalar {
	b := make([]byte, 32)
	binary.LittleEndian.PutUint64(b, n)
	sc, err := edwards25519.NewScalar().SetCanonicalBytes(b)
	if err != nil {
		// This should not happen for small n
		panic(err)
	}
	s.s = sc
	return s
}

// Uint16 returns the uint16 representation of the scalar.
// This is not a constant-time operation.
func (s *Scalar) Uint16() uint16 {
	b := s.s.Bytes()
	return binary.LittleEndian.Uint16(b)
}

// Point returns the underlying edwards25519.Point.
func (e *Element) Point() *edwards25519.Point {
	return e.e
}

// Scalar returns the underlying edwards25519.Scalar.
func (s *Scalar) Scalar() *edwards25519.Scalar {
	return s.s
}
